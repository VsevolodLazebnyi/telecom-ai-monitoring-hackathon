import requests
from urllib.parse import urljoin
import copy
import time

class GrafanaHandler:
    def __init__(self, grafana_host: str, grafana_key: str, org_id: int | None = None, timeout_sec: int = 15):
        # Важно: grafana_host должен быть полным URL, например: "http://localhost:3000"
        self.grafana_host = grafana_host.rstrip("/")
        self.grafana_key = grafana_key
        self.timeout = timeout_sec

        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"{self.grafana_key}",
        }
        if org_id is not None:
            # если используется multi-org — добавь заголовок
            self.headers["X-Grafana-Org-Id"] = str(org_id)

    def _abs(self, path: str) -> str:
        return urljoin(self.grafana_host + "/", path.lstrip("/"))

    def _dash_link(self, url_from_api: str | None) -> str | None:
        if not url_from_api:
            return None
        # API обычно возвращает относительный путь "/d/xxxx/slug"
        return urljoin(self.grafana_host + "/", url_from_api.lstrip("/"))

    def fetch_datasources(self):
        url = self._abs("/api/datasources")
        resp = requests.get(url, headers=self.headers, timeout=self.timeout)
        if resp.status_code == 200:
            processed_ds = []
            for ds in resp.json():
                match ds.get("typeName"):
                    case "Prometheus":
                        modified = ds.copy()
                        modified["uid"] = ds.get("uid", "")
                        modified["name"] = str.lower(ds.get("typeName", ""))
                        processed_ds.append(modified)
                    case "PostgreSQL":
                        modified = ds.copy()
                        modified["uid"] = ds.get("uid", "")
                        modified["name"] = str.lower(ds.get("typeName", ""))
                        processed_ds.append(modified)
                    case _:
                        pass
            return processed_ds
        return []

    # --- Дополнительно: получить/удалить дашборд по uid (для 412-конфликтов)
    def get_dashboard_by_uid(self, uid: str):
        url = self._abs(f"/api/dashboards/uid/{uid}")
        resp = requests.get(url, headers=self.headers, timeout=self.timeout)
        if resp.status_code == 200:
            return resp.json()
        return None

    def delete_dashboard_by_uid(self, uid: str):
        url = self._abs(f"/api/dashboards/uid/{uid}")
        resp = requests.delete(url, headers=self.headers, timeout=self.timeout)
        return resp.status_code in (200, 202)

    # --- Нормализация входного JSON перед импортом
    @staticmethod
    def _sanitize_dashboard_json(raw: dict) -> dict:
        d = copy.deepcopy(raw)

        # 1) id: убрать (или выставить None), чтобы не мешал созданию/overwrite
        if "id" in d and d["id"] not in (None, 0):
            # безопаснее совсем удалить — Grafana сам проставит id
            d.pop("id", None)

        # 2) uid: оставить, если есть; если нет — не выдумывать сложных значений
        # (можно оставить без uid — Grafana сгенерирует; но если uid есть, импорт будет детерминирован)
        uid = d.get("uid")
        if uid is not None and not isinstance(uid, str):
            # на всякий случай приводим к строке
            d["uid"] = str(uid)

        # 3) schemaVersion, timezone, time — убедиться, что присутствуют
        d.setdefault("schemaVersion", 36)
        d.setdefault("timezone", "browser")
        d.setdefault("time", {"from": "now-1h", "to": "now"})

        # 4) title — обязателен
        d.setdefault("title", "Generated Dashboard")

        # 5) folderId можно выставить на ноль в payload, но в сам dashboard класть не обязательно
        # 6) Минимальная чистка panels.datasources — если у тебя уже есть логика приведения, оставить как есть

        return d

    def apply_dashboard(self, dashboard_json: dict, folder_id: int = 0, allow_delete_on_conflict: bool = True):
        """
        Импорт/обновление дашборда.
        - Успех: status 200 (update) или 201 (create)
        - Конфликт: status 412 — пробуем удалить старый по uid и повторить (если allow_delete_on_conflict=True)
        """
        url = self._abs("/api/dashboards/db")

        # Нормализуем JSON
        sanitized = self._sanitize_dashboard_json(dashboard_json)

        payload = {
            "dashboard": sanitized,
            "overwrite": True,
            "folderId": folder_id,
            "message": "Auto-generated by Prometheus Viewer",
        }

        try:
            resp = requests.post(url, json=payload, headers=self.headers, timeout=self.timeout)

            if resp.status_code in (200, 201):
                data = resp.json()
                link = self._dash_link(data.get("url"))
                data["url"] = link or ""
                return data

            if resp.status_code == 412:
                # Конфликт. Чаще всего дашборд уже существует с таким uid/slug.
                uid = sanitized.get("uid")
                if allow_delete_on_conflict and uid:
                    # 1) пробуем удалить старый
                    deleted = self.delete_dashboard_by_uid(uid)
                    if not deleted:
                        return {"error": "API Error 412 (conflict)", "details": f"Failed to delete existing dashboard uid={uid}. Response: {resp.text}"}
                    # 2) retry
                    time.sleep(0.5)
                    retry = requests.post(url, json=payload, headers=self.headers, timeout=self.timeout)
                    if retry.status_code in (200, 201):
                        data = retry.json()
                        link = self._dash_link(data.get("url"))
                        data["url"] = link or ""
                        return data
                    else:
                        return {"error": f"API Error {retry.status_code} after delete+retry", "details": retry.text}
                else:
                    return {"error": "API Error 412 (conflict)", "details": resp.text}

            # Прочие ошибки
            return {"error": f"API Error {resp.status_code}", "details": resp.text}

        except Exception as e:
            return {"error": str(e)}